移除反调试。

1. 将 00000000004025A1 处对 ptrace 结果的检查的条件跳 nop 掉。
2. 将 0000000000402638 处设置 SIGTRAP 的调用直接换成 call SIGTRAP 的 handler （0000000000402469）。

先分析第一次检查的算法。

bool __fastcall hannoi(char *arr)
{
  int v1; // eax@2
  unsigned int _edx; // edx@2
  bool v3; // al@16
  int i; // [sp+Ch] [bp-Ch]@1

  i = 0;
  while ( 1 )
  {
    v1 = i++;
    _edx = (unsigned int)((unsigned __int64)arr[v1] >> 32) >> 28;
    switch ( (((_BYTE)_edx + arr[v1]) & 0xF) - _edx )
    {
      case 1u:
        move0to1();
        break;
      case 2u:
        move0to2();
        break;
      case 3u:
        move1to0();
        break;
      case 4u:
        move1to2();
        break;
      case 5u:
        move2to0();
        break;
      case 6u:
        move2to1();
        break;
      default:
        v3 = ::arr[5] && ::arr[6] && ::arr[7] && ::arr[8] && ::arr[9];
        return v3 != 0;
    }
    (unsigned __int8)round_check();
  }
}

最开始的 edx 迷惑人，一定为 0，无视。相当于计算低 4 bit，1-6 执行对应的操作，否则进行检查。

arr 为 15 字节的数组，每个柱子 5 字节，共三个柱子。因此最终在检查 5 - 9 （第一个柱子）是否为满。中间的柱子为目标。

接着分析第二轮检查。就是和预设的 MD5 比较。

bool __fastcall hash(const char *in)
{
  unsigned int len; // eax@1
  bool result; // al@1
  __int64 v3; // rbx@1
  char v4; // [sp+10h] [bp-80h]@1
  char iv[24]; // [sp+20h] [bp-70h]@1
  __int64 v6; // [sp+78h] [bp-18h]@1

  v6 = *MK_FP(__FS__, 40LL);
  set_iv((__int64)iv);
  len = strlen(in);
  md5((int *)iv, (char *)in, len);
  result = md5verify((int *)iv, &v4);
  v3 = *MK_FP(__FS__, 40LL) ^ v6;
  return result;
}

先解决汉诺塔。有一个很长很长很长的源文件。慢慢读。

使用 BFS + hash set 剪枝。

#include <cassert>
#include <cstdint>
#include <array>
#include <queue>
#include <boost/functional/hash.hpp>
#include <unordered_set>
#include <openssl/md5.h>

static constexpr auto kMaxPlate = 5;
static constexpr auto kMaxPillar = 3;
static constexpr auto kMaxPath = 31 - 7; // 7 = TSCTF{}

static constexpr auto kHighBegin = 0b00100000;
static constexpr auto kHighEnd   = 0b01110000;
static constexpr auto kHighDelta = 0b00010000;

// 0: count, [1, kMaxPillar]: plate
static constexpr uint8_t kMethod[3][3] = {
  {0, 1, 2},
  {3, 0, 4},
  {5, 6, 0}
};

// F2 DB 78 6E 5F 13 B2 7F 9B 8D 3B 35 1F 6D E1 5
static constexpr auto kTarget = std::array<uint8_t, MD5_DIGEST_LENGTH>{
    uint8_t('\xF2'), uint8_t('\xDB'), uint8_t('\x78'), uint8_t('\x6E'),
    uint8_t('\x5F'), uint8_t('\x13'), uint8_t('\xB2'), uint8_t('\x7F'),
    uint8_t('\x9B'), uint8_t('\x8D'), uint8_t('\x3B'), uint8_t('\x35'),
    uint8_t('\x1F'), uint8_t('\x6D'), uint8_t('\xE1'), uint8_t('\x5')
};

struct Block {
  uint8_t n;
  uint8_t v[kMaxPlate];

  bool full() const { return n == kMaxPlate; }
  bool empty() const { return n == 0; }

  void push(uint8_t t) {
    assert(!full());
    v[n++] = t;
  }

  uint8_t &pop() {
    assert(!empty());
    return v[--n];
  }

  uint8_t &next() {
    assert(!full());
    return v[n];
  }

  uint8_t &top() {
    assert(!empty());
    return v[n - 1];
  }

  uint8_t top() const {
    assert(!empty());
    return v[n - 1];
  }

  void Print() const {
    printf("\t| ");
    for (auto i = 0; i < n; ++i) {
      printf("%d ", v[i]);
    }
    printf("\n");
  }

  template <typename... T> Block(T... ts) : n(sizeof...(ts)), v{ts...} {}
};

using Pillar = Block[kMaxPillar];

struct Path;
using PathQueue = std::deque<Path>;

struct Path {
  using Buf = std::array<char, kMaxPath + 1>;

  // [from][to]
  int length;
  Pillar state;
  std::array<uint8_t, kMaxPath>  ops;

  Path Move(int fromi, int toi) const {
    auto method = kMethod[fromi][toi];
    auto new_path = *this;
    new_path.state[toi].push(new_path.state[fromi].pop());
    new_path.ops[new_path.length++] = method;
    return new_path;
  }

  void PrintStep() const {
    printf("  Step:\n");
    for (auto i = std::begin(ops); i != std::begin(ops) + length; ++i) {
      switch (*i) {
      case 1:  printf("\t1: 0 -> 1\n"); break;
      case 2:  printf("\t2: 0 -> 2\n"); break;
      case 3:  printf("\t3: 1 -> 0\n"); break;
      case 4:  printf("\t4: 1 -> 2\n"); break;
      case 5:  printf("\t5: 2 -> 0\n"); break;
      case 6:  printf("\t6: 2 -> 1\n"); break;
      default: printf("\t!!!!!\n"); break;
      }
    }
  }

  void PrintPillar() const {
    printf("  Pillar:\n");
    for (const auto &p : state) p.Print();
  }

  void Print() const {
    printf("Path(%d)\n", length);
  }
};

struct PathHash {
  size_t operator()(const Path &path) const {
    size_t result = 0;
    for (const auto &p: path.state) {
      boost::hash_combine(result, p.n);
      for (auto i = 0; i < p.n; ++i) {
        boost::hash_combine(result, p.v[i]);
      }
    }
    return result;
  }
};

struct PathEqual {
  bool operator()(const Path &x, const Path &y) const {
    for (auto i = 0; i < kMaxPillar; ++i) {
      const auto &xi = x.state[i], &yi = y.state[i];
      return std::equal(xi.v, xi.v + xi.n, yi.v, yi.v + yi.n);
    }
    return true;
  }
};

using PathSet = std::unordered_set<Path, PathHash, PathEqual>;

void GenerateMoves(const Path &p, PathQueue &q, PathSet &s) {
  for (auto fromi = 0; fromi < kMaxPillar; ++fromi) {
    auto &from = p.state[fromi];
    if (from.empty()) continue;
    for (auto toi = 0; toi < kMaxPillar; ++toi) {
      auto &to = p.state[toi];
      if (fromi == toi) continue;
      if (to.full()) continue;
      if (!to.empty() && from.top() >= to.top()) continue;

      auto new_path = p.Move(fromi, toi);
      if (s.find(new_path) != s.end()) continue;

      s.insert(new_path);
      q.push_back(new_path);
    }
  }
}

主函数如下：

int main() {
  auto p = Path{};
  p.state[0] = {uint8_t(4), uint8_t(1)};
  p.state[1] = {uint8_t(2)};
  p.state[2] = {uint8_t(5), uint8_t(3)};

  // p.state[0] = {uint8_t(3), uint8_t(1)};
  // p.state[1] = {uint8_t(5), uint8_t(4), };
  // p.state[2] = {uint8_t(2)};
  auto queue = PathQueue{p};
  auto set = PathSet{p};

  while (!queue.empty()) {
    auto e = queue.front();
    queue.pop_front();
    // e.Print();
    // e.PrintStep();
    // e.PrintPillar();

    if (e.state[1].full()) {
      e.Print();
      e.PrintStep();
      e.PrintPillar();
      Verify(e);
    }

    // Drop the lengthy ones
    if (e.length >= kMaxPath - 1) continue;
    GenerateMoves(e, queue, set);
  }

  return 0;
}


确定了最少元素的解后，接着生成高 4 bit。枚举每种操作对应的高 4 bit，使得输出为 ASCII。算出结果后 MD5 验证。OpenSSL 走起。

void Verify(const Path &path) {
  auto md5 = std::array<uint8_t, MD5_DIGEST_LENGTH>{};
  auto buf = std::array<uint8_t, kMaxPath + 1>{};
  auto buf_begin = reinterpret_cast<const uint8_t *>(buf.data());
  auto map = std::array<char, 7>{};

  for (auto i1 = kHighBegin; i1 <= kHighEnd; i1 += kHighDelta) {
    map[1] = 1 | i1;
    for (auto i2 = kHighBegin; i2 <= kHighEnd; i2 += kHighDelta) {
      map[2] = 2 | i2;
      for (auto i3 = kHighBegin; i3 <= kHighEnd; i3 += kHighDelta) {
        map[3] = 3 | i3;
        for (auto i4 = kHighBegin; i4 <= kHighEnd; i4 += kHighDelta) {
          map[4] = 4 | i4;
          for (auto i5 = kHighBegin; i5 <= kHighEnd; i5 += kHighDelta) {
            map[5] = 5 | i5;
            for (auto i6 = kHighBegin; i6 <= kHighEnd; i6 += kHighDelta) {
              map[6] = 6 | i6;

              auto length = path.length;
              for (auto i = 0; i < length; ++i) buf[i] = map[path.ops[i]];
              MD5(buf_begin, length, md5.data());
              for (auto i : md5) printf("%02x", i);
              printf(" ");
              printf("%s\n", std::string(buf_begin, buf_begin + length).c_str());
              if (md5 == kTarget) printf("XXXXXXn");
            }
          }
        }
      }
    }
  }
}

然后就各种写崩。然后调。然后调出来。然后提交。然后没有然后。
